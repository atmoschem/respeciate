#' @name sp.pls
#' @title (re)SPECIATE profile Positive Least Squares
#' @aliases sp_pls_profile pls_report pls_refit_species pls_add_parent

#' @description Functions for Positive Least Squares (PSL) fitting of
#' (re)SPECIATE profiles

#' @description
#' \code{sp_pls_profile} builds PSL models for supplied profile(s) using
#' the \code{\link{nls}} function, the 'port' algorithm and a lower
#' limit of zero for all model outputs to enforce the positive fits. The
#' modeled profiles are typically from an external source, e.g. a
#' measurement campaign, and the models are fit using a set of reference
#' profiles, here typically from (re)SPECIATE, to provide a measure of
#' source apportionment based on the assumption that the profiles in the
#' reference set are representative of the mix that make up the modeled
#' sample. The \code{pls_} functions work with \code{sp_pls_profile}
#' outputs, and are intended to be used when refining and analyzing
#' these PLS models.

#' @param x A \code{respeciate} object, a \code{data.frame} of
#' profiles in standard long form, intended for PLS modelling.
#' @param ref A \code{respeciate} object, a \code{data.frame} of
#' profiles also in standard long form, intended to be used as sample
#' of references profiles to fit \code{x} as a linear combination
#' of. See also Notes.
#' @param power A numeric, an additional factor to be added to
#' weightings when fitting the PLS model. This is applied in the form
#' \code{weight^power}, and increasing this, increases the relative
#' weighting of the more heavily weighted measurements. Values in the
#' range \code{1 - 2.5} are sometimes helpful.
#' @param ... additional arguments, currently ignored.
#' @param pls A \code{sp_pls_profile} output, only used by \code{pls_}
#' functions.
#' @param name Character class, for \code{pls_refit_species} only, the
#' name of the species to refit. All other species in the reference
#' profiles are held 'as is' and the \code{name}d species is refit based on
#' previous PLS estimated source contribution time-series, then these are
#' in turn refit using the new profiles generated by re-distributing the
#' \code{name}d species.
#' @param parent (for \code{pls_add_parent} only) a data.frame of measurements
#' of an additional species. This is treated as the sample parent (or a proxy
#' for this), e.g. the total particulate matter (PM) measurement for
#' (percentage) PM profiles. It is added to \code{x}, dummy entries are added
#' to \code{ref} with a start value of 100 (percent), and the model is refitted.

#' @return \code{sp_pls_profile} returns a list of nls models, one per
#' profile/measurement set in \code{x}. The \code{pls_} functions work with
#' these outputs. \code{pls_report} generates a \code{data.frame} of
#' model outputs, and is used of several of the other \code{pls_}
#' functions. \code{pls_refit_species} and \code{pls_add_daughter}
#' return the supplied \code{sp_pls_profile} output, updated on the
#' basis of the \code{pls_} function call.

#' @note This implementation of PLS applies the following modeling constaints:
#'
#' 1. The generate a model of \code{x} that is positively constained linear
#' product of the profiles in \code{ref}, so outputs can only be
#' zero or more.  Although the model is generated using \code{\link{nls}},
#' which is a Nonlinear Least Squares (NLS) model, the fitting term applied
#' in this case is linear.
#'
#' 2. The number of species in \code{x} must be more that the number of
#' profiles in \code{ref}, to reduce the likelihood of over-fitting.
#'
#'

# GENERAL NOTES

# TO DO
# link to CMB as crude form of CMB and reference?

# these all need code tidying


############################
############################
## sp_pls_profile
############################
############################

#' @rdname sp.pls
#' @export

##   now imports from xxx.r
##   #' @import data.table

#This is version 2

#version 1 combined version2 and pls_report
#now separated because it simplified pls model reworking

#like to keep model args
#model does not seem to be tracking them for rescale

sp_pls_profile <- function(x, ref,
                            power = 1,
                            ...){

  ##################
  #from rough code
  ##################

  ########################
  #only allowing species <
  if(length(unique(ref$PROFILE_CODE)) >= length(unique(x$SPECIES_ID))){
    stop("sp_pls: need more species or less profiles [species < profile]",
         call. = FALSE)
  }

  ####################
  #make sure we only have one species / profile
  ####################
  #tidying
  .pr.cd <- unique(x$PROFILE_CODE)
  ##  .xx <- respeciate:::rsp_tidy_profile(x)
  .xx <- lapply(.pr.cd, function(y){
    .x <- x[x$PROFILE_CODE==y,]
    .x <- sp_average_profile(.x, y, .x$PROFILE_NAME[1])
    .x
  })
  .xx <- data.table::rbindlist(.xx)
  #should be same! redundant
  .pr.cd <- unique(.xx$PROFILE_CODE)

  ####################
  #reduce ref to just species in x
  ###################
  #no point to look at any species not in x
  ref <- subset(ref, SPECIES_ID %in% unique(.xx$SPECIES_ID))

  ###################
  #nudge
  ###################
  #dropping nudge from version 2
  ##
  #nb: method was nudge before analysis
  #and a nudge back after
  #   nudge(identified.species)->pls->report->nudge back(identified.species)

  #if(!is.null(nudge)){
  #  for(i in nudge){
  #    #ref might have both WEIGHT_PERCENT and .value
  #    ref[ref$SPECIES_NAME==i, "WEIGHT_PERCENT"] <-
  #      ref[ref$SPECIES_NAME==i, "WEIGHT_PERCENT"] * 10
  #    .xx[.xx$SPECIES_NAME==i, "WEIGHT_PERCENT"] <-
  #      .xx[.xx$SPECIES_NAME==i, "WEIGHT_PERCENT"] * 10
  #    .xx[.xx$SPECIES_NAME==i, ".value"] <-
  #      .xx[.xx$SPECIES_NAME==i, ".value"] * 10
  #  }
  #}

  ##############################
  #main step/ once per profile
  ##############################
  #can we replace this with data.table
  ans <- lapply(.pr.cd, function(y){
    .test <- try({
      #need to try this because it does not always work
      .x <- as.data.frame(.xx[.xx$PROFILE_CODE==y,])
      .x <- sp_average_profile(.x, "test", "1_test")

      #might not need one of this-and-same-above
      #might be better doing it here...
      .tmp <- subset(ref, ref$SPECIES_ID %in% unique(.x$SPECIES_ID))

      #could change this with rbindlist version??
      .ref <- intersect(names(.x), names(.tmp))
      .out <- rbind(.x[.ref], .tmp[.ref])
      .out <- sp_dcast_profile(.out)

      #build formula and model args
      .tmp <- names(.out)
      .tmp <- .tmp[!.tmp %in% c("SPECIES_ID", "SPECIES_NAME", "test")]
      #zero cases for port function
      .ls <- paste("m_", .tmp, sep="")
      .ls2 <- lapply(.ls, function(x){0})
      names(.ls2) <- .ls
      .for <- paste("(m_", .tmp, "*`", .tmp, "`)", sep="", collapse = "+")
      .for <- as.formula(paste("test~", .for))

      #run nls/pls
      mod <- nls(.for, data=.out,
                 weights = (1/.out$test)^power, # think about weighting
                 start=.ls2, lower=.ls2,
                 algorithm="port",
                 control=nls.control(tol=1e-5) #think about tolerance
      )

      #if we need to calculate AIC on a case-by-case basis...
      #for model, I think we need to use stats:::logLik.nls for AIC calc...
      #see
      #https://stackoverflow.com/questions/39999456/aic-on-nls-on-r
      #(currently calculating AIc on the lm model on the overall fit on
      # all species in all profiles as part of pls_report)

      ###################################
      #following now in pls_report
      ###################################
      #  returning list of models
      ##.tmp <- summary(mod)$coefficients
      ##.p.mod <- .tmp[,4]
      ##names(.p.mod) <- gsub("m_", "p_", names(.p.mod))
      ##.out <- data.frame(PROFILE_CODE = y,
      ##           t(.tmp[,1]),
      ##           t(.p.mod))
      ##.out

      #output list of mod + data
      ################################
      #could add args?
      #  then drop power from pls_ function formals
      #       or allow as an overwrite only...
      list(mod=mod,
           data = .out)

    }, silent = TRUE)
    if(class(.test)[1]=="try-error"){
      NULL
    } else {
      .test
    }
  })
  names(ans) <- .pr.cd

  #returns the list of nls models
  return(ans)

}


#############################
#############################
## pls_report
#############################
#############################

#' @rdname sp.pls
#' @export

##   now imports from xxx.r
##   #' @import data.table

# this is the model report table
# other pls_ functions use output
#    so take care if changes

pls_report <- function(pls){

  ans <- lapply(names(pls), function(x){
    .xx <- pls[[x]]
    .out <- .xx$data
    .tmp <- summary(.xx$mod)$coefficients
    .p.mod <- .tmp[,4]
    names(.p.mod) <- gsub("m_", "p_", names(.p.mod))
    .out <- data.frame(PROFILE_CODE = x,
                       .out,
                       t(.tmp[,1]),
                       t(.p.mod),
                       pred = predict(.xx$mod, newdata=.xx$data),
                       check.names=FALSE)
    .out
  })
  ans <- data.table::rbindlist(ans, use.names=TRUE, fill=TRUE)
  #####################
  #think about calling it test
  ans$.value <- ans$test
  mod2 <- lm(pred~.value, data=ans)
  ans$adj.r.sq <- summary(mod2)$adj.r.squared
  ans$slope <- summary(mod2)$coefficients[2,1]
  ans$p.slope <- summary(mod2)$coefficients[2,4]
  ans$intercept <- summary(mod2)$coefficients[1,1]
  ans$p.intercept <- summary(mod2)$coefficients[1,4]
  ###########
  #(also noted in sp_pls_profile)
  #if we calculate AIC for individual models
  #need to read this:
  #https://stackoverflow.com/questions/39999456/aic-on-nls-on-r
  #see stats:::logLik.nls for AIC calc...
  #if we need to calculate it on a case-by-case basis...
  ans$AIC <- AIC(mod2)

  as.data.frame(ans)
}



###########################
###########################
## pls_refit_species
###########################
###########################

#' @rdname sp.pls
#' @export

##   now imports from xxx.r
##   #' @import data.table

#like to drop power from formals
#   maybe ignore or pass overwrites via ...?


pls_refit_species <- function(pls, name, power=1, ...){
  .xx <- pls_report(pls)
  #name might want to be case-non-sensitive at some point
  #think about how to do this one...
  .data <- .xx[.xx$SPECIES_NAME==name,]
  #get and hold all the m_ values
  #update profile contributions for named species
  .ms <- names(.data)[grepl("^m_", names(.xx))]
  .xs <- gsub("^m_", "", .ms)
  .for <- paste("(`", .ms, "`*`", .xs, "`)",
                sep="", collapse = "+")
  .for <- as.formula(paste("test~", .for))
  .da <- .data[!names(.data) %in% .xs]


  .ls <- lapply(.xs, function(x){0})
  names(.ls) <- .xs

  #################
  #user might want to set this???

  .ls2 <- lapply(.xs, function(x){.data[1, x]})
  names(.ls2) <- .xs

  mod <- nls(.for, data=.da,
             #weights = 1/(.out$test^push), # think about weighting
             start=.ls2, lower=.ls,
             algorithm="port",
             control=nls.control(tol=1e-5) #think about tolerance
  )

  .data[.xs] <- data.frame(t(coefficients(mod)))

  #lazy
  .ans <- .data

  for(i in .ans$PROFILE_CODE){
    .ii <- subset(.ans, PROFILE_CODE==i)
    .ii <- .ii[names(.ii) %in% names(pls[[i]]$data)]
    pls[[i]]$data <- subset(pls[[i]]$data, SPECIES_NAME!=name)
    pls[[i]]$data <- rbind(pls[[i]]$data, .ii)
    #rebuild model
    .for <- as.character(formula(pls[[i]]$mod))
    .for <- as.formula(paste(.for[2], .for[1], .for[3], sep=""))
    .ms <- names(pls[[i]]$data)
    .ms <- .ms[!.ms %in% c("SPECIES_ID", "SPECIES_NAME", "test")]
    .ls <- lapply(.ms, function(x){0})
    names(.ls) <- paste("m_", .ms, sep="")
    .da <- pls[[i]]$data

    pls[[i]]$mod <- nls(.for, data=.da,
                        weights = (1/.da$test)^power, # think about weighting
                        start=.ls, lower=.ls,
                        algorithm="port",
                        control=nls.control(tol=1e-5,
                                            warnOnly = TRUE) #think about tolerance
    )
  }

  pls

}




####################################
####################################
## pls_add_parent
####################################
####################################


#' @rdname sp.pls
#' @export

##   now imports from xxx.r
##   #' @import data.table

#############################
#this needs a lot of work
#############################


# (like pls_refit_species)
# like to drop power from formals
#   maybe ignore or pass overwrites via ...?

# parent could already be in x
#    then parent could just be the name of parent???


pls_add_parent <- function(pls, parent, power=1, ...){

  .out <- pls_report(pls)
  #parent should only have one species
  #and have same profiles as pls model data
  #and its contribution to all sources is set by .value
  .out <- subset(.out, SPECIES_ID == unique(.out$SPECIES_ID)[1])
  .test <- c("PROFILE_CODE", ".value", "WEIGHT_PERCENT")
  .test <- names(parent)[names(parent) %in% .test]
  .data <- parent[.test]
  names(.data)[2] <- "parent"
  .data <- merge(.out, .data[c(1:2)])

  #formula
  .ms <- names(.data)[grepl("^m_", names(.out))]
  .for <- paste("(`", .ms, "`*`", gsub("^m_", "n_", .ms), "`)",
                sep="", collapse = "+")
  .for <- as.formula(paste("parent~", .for))

  .ls <- lapply(.ms, function(x){0})
  names(.ls) <- gsub("^m_", "n_", .ms)
  #################
  #user might want to set this???

  .ls2 <- lapply(.ms, function(x){100})
  names(.ls2) <- gsub("^m_", "n_", .ms)

  mod <- nls(.for, data=.data,
             #weights = (1/.out$test)^power, # think about weighting
             start=.ls2, lower=.ls,
             algorithm="port",
             control=nls.control(tol=1e-5) #think about tolerance
  )
  .ans <- data.frame(
    PROFILE_CODE = .data$PROFILE_CODE,
    SPECIES_ID = parent$SPECIES_ID[1],
    SPECIES_NAME = parent$SPECIES_NAME[1],
    t(coefficients(mod)),
    test = .data$parent
  )
  names(.ans) <- gsub("^n_", "", names(.ans))
  for(i in .ans$PROFILE_CODE){
    .ii <- subset(.ans, PROFILE_CODE==i)
    .ii <- .ii[names(.ii) != "PROFILE_CODE"]
    pls[[i]]$data <-
      rbind(pls[[i]]$data, .ii)
    #rebuild model
    .for <- as.character(formula(pls[[i]]$mod))
    .for <- as.formula(paste(.for[2], .for[1], .for[3], sep=""))
    .ms <- names(pls[[i]]$data)
    .ms <- .ms[!.ms %in% c("SPECIES_ID", "SPECIES_NAME", "test")]
    .ls <- lapply(.ms, function(x){0})
    names(.ls) <- paste("m_", .ms, sep="")
    .da <- pls[[i]]$data

    pls[[i]]$mod <- nls(.for, data=.da,
                        weights = (1/.da$test)^power, # think about weighting
                        start=.ls, lower=.ls,
                        algorithm="port",
                        control=nls.control(tol=1e-5) #think about tolerance
    )
  }

  pls

}

